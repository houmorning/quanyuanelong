#include "stdio.h"
#include "conio.h"
#include "stdlib.h"
#include "windows.h"

#define LEVEL 13
#define COVER 0
#define Y_STEP 1
#define X_STEP 2
#define KEY_Esc 0x1b
#define HIGH 37
#define WIDE 160

int Level=-1;
char Order = 'd';
char Map[HIGH][WIDE]={""};
// char Map_Logic[HIGH][WIDE] = {""};
//char Map_Draw[HIGH][WIDE] = {""};
Monster_Coord[9][2] = {0};//第一维表示某波的怪物数量，第二维表示怪物坐标

int Coord_Human_Y = 18, Coord_Human_X = 3; //定义人物初始位置
char *Coord_Human_Body[WIDE];
Coord_Human_Body = Map_Draw;

struct Human
{
    int job;
    char name[50];
    int blood;
    int power;
    int glad;
    int skill;
    int weapon_id;
}Player;

struct Monster
{
    int id;
    char name[100];
    int blood;
    int harm;
};

struct Weapon  //此处所有的gan都是抽象  //实际代表的可能是magic  //也可能是大刀片子
{
    int id;  //武器ID
    int type;  //武器类型  //这部分暂时还没有讨论清楚
    char name[100];  //武器的名称
    int clip;  //武器弹夹  //武器蓄能满格时能发动攻击的次数
    int barrel;  //武器枪管  //表示每次攻击能飞出的子弹数量
    int time;  //该武器子弹飞行的帧数
    int pierce;  //布尔类型  //表示这种武器攻击时是否能够穿透怪物  //是否会被怪物阻挡

}Chopper;  //这个词是大刀片子的意思  //是我现查的


//下面这三个数组用于描述子弹  //还没有编排好合理的代码位置  //后续版本会进行修改
Ammo_Count[Chopper.clip] = {0};  //0为可用, !0为占用  //存入攻击时【武器】初始位置指针
Bullet_Location[Chopper.barrel][2] = {0}; //B_L[i][0], B_L[i][0]分别为每颗子弹初始位置
Bullet_Exist_Famer_Numbers[Chopper.time][2] = {0};  //BEFN[i][0], BEFN[i][0]分别为每颗子弹每帧与【武器】初始位置的偏移量
//BEFN可以用来找到每帧各子弹绝对位置
//可以考虑新数组存放这些数据, 在渲染中复用

int Coord_Human_Body_Offset(int x, int y)  //可以改为其他指针通用的相对偏移量  //下个版本考虑修改
{
    //人物身体位置的相对偏移量
    return *(*(Coord_Human_Body+Coord_Human_Y + y ) + Coord_Human_X + x);
}

int Human_Move(int x,int y){
    //if  这里是用来判断是否撞墙
    if  (Coord_Human_Body_Offset(x+1, y)!='#' && Coord_Human_Body_Offset(x-1, y)!='#'){
        Coord_Human_Y += y;
        Coord_Human_X += x;
    }
}


int Human_Fight(){
    //判断攻击线程是否被占用                                  //get
    //攻击后切换为下一个攻击线程                              //get
    //根据人物方向判断偏移方向
    //根据玩家按下攻击操作设置偏移原始位置                     //get
    //根据初始位置和偏移方向和武器种类和当前帧数确定攻击范围
    //判定攻击范围内是否攻击到怪物模型
    //判定攻击范围是否攻击到墙
    //碰到墙后子弹阻碍
    //根据武器伤害值给碰到的怪物减血  //可以考虑传出数据在  正常处理中判断是否攻击到怪物
    //
    //恢复攻击值                                             

    switch(Order)
    {
        case 'd':
            *(*(p + bl[i][1]) + bl[i][0]);
            break;
        case 'a':
            *(*(p - bl[i][1]) - bl[i][0]);
            break;
        case 's':
            *(*(p + bl[i][0]) + bl[i][1]);
            break;
        case 'w':
            *(*(p - bl[i][0]) - bl[i][1]);
            break;
    }
    
    
}

int Event_Response(){
    if(kbhit()){
        switch(Order=getch()){
            case 'W':case 'w':Human_Move(-1,0);break;
            case 'S':case 's':Human_Move(1,0);break;
            case 'A':case 'a':Human_Move(0,-2);break;
            case 'D':case 'd':Human_Move(0,2);break; 
            case 'F':case 'f':Human_Fight();break;//C语言不能直接写默认函数
        }
    }
}
int Mode_Crash(int ax, int ay,int ah, int aw,int bx, int by, int bh, int bw){
    //判断两个物体的模型是否发生碰撞
    //返回值为 1||0
    if (abs(ax-bx)>aw+bw||abs(ay-by)>ah+bh)
        return 0;
    else if (abs(ax-bx)==aw+bw||abs(ay-by)==ah+bh)
        return 1;
    else
        return -1;
}
int Monster_Build(int count){
    //怪物生成
    //参数为怪物的种类和个数
    //重点注意像素变化
    //下次更改写成宏定义

    int x, y, i;
    for (i = 0; i < count;i++){
        x = rand() % WIDE + 5;
        y = rand() % HIGH;
        if (Map_Logic[y][x]!='#'&& Mode_Crash(Coord_Human_X,Coord_Human_Y,1,x,y,0)){
        
            Monster_Coord[i][0] = x;
            Monster_Coord[i][1] = y;
        }
    }
}

//更新怪物列表

int Draw_Set_Monster(int count){
    //根据怪物位置放入怪物模型
    int i;
    for (i = 0; i < count;i++){
        Map_Draw[Monster_Coord[i][1]][Monster_Coord[i][0]]='@'
    }
}
int Draw_Set_Human(){
    //根据人物位置放入人物模型
    char strhead = 'O', strbody = 'H', strrarm = '>', strlarm = '<',  strleg = 'I', strdick = ' ';
    *(*(Coord_Human_Body+Coord_Human_Y - 1 ) + Coord_Human_X     ) = strhead;
    *(*(Coord_Human_Body+Coord_Human_Y     ) + Coord_Human_X     ) = strbody;
    *(*(Coord_Human_Body+Coord_Human_Y     ) + Coord_Human_X + 1 ) = strrarm;
    *(*(Coord_Human_Body+Coord_Human_Y     ) + Coord_Human_X - 1 ) = strlarm;
    *(*(Coord_Human_Body+Coord_Human_Y + 1 ) + Coord_Human_X - 1 ) = strleg;
    *(*(Coord_Human_Body+Coord_Human_Y + 1 ) + Coord_Human_X + 1 ) = strleg;
    *(*(Coord_Human_Body+Coord_Human_Y + 1 ) + Coord_Human_X     ) = strdick;
}
int Draw_Set_Weapon(){
    //根据人物位置和方向将武器放入画面
    char strweapon = '!';
    switch (Order)
    {
        case 'W':
        case 'w':
        case 'A':
        case 'a':*(*(Coord_Human_Body+Coord_Human_Y) + Coord_Human_X - 1 ) = strweapon;
            break;
        case 'S':
        case 's':
        case 'D':
        case 'd':*(*(Coord_Human_Body+Coord_Human_Y) + Coord_Human_X + 1 ) = strweapon;
            break;
    
        default:
            break;
    }
}
int Draw_Set_Bullet(){
    //将子弹绘入画面
}
int Draw_Human_Count(){
    //实时显示人物剩余攻击次数
}
int Draw_Render_Interface(){
    //整体界面渲染
    int i, j;
    for (i = 0; i < HIGH;i++){
        for (j = 0; j < WIDE;j++){
            printf("");
            //是否可以直接打印字符串？
            //写一个例子验证一下
        }
    }
}
int Render_Interface(){
    Draw_Set_Background();  //所有的墙必须出现在偶数位置
    //横坐标必须是 6,12,18,24,30  
    //纵坐标必须是n*10，n*10+1的倍数 
    //每两堵墙之间可以跨三步
    Draw_Set_Monster();
    Draw_Set_Human();
    Draw_Set_Weapon();
    //Draw_Set_Prop_Redorp();
    Draw_Set_Bullet();
    //Draw_Set_Grass();
    //Draw_Set_Prop_Name();

    Draw_Render_Interface();
}

int main(){
    system("mode con cols=160 lines=36");
    srand((unsigned)malloc(1));//生成随机数种子
    //预设控制台窗口大小
    while (1){ 
        Event_Response();
        //事件响应
        Normal_Operation();
        //常规处理
        Render_Interface();
        //界面渲染
        }
}
